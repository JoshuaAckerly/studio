name: Integration - Storage (MinIO)

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [ main ]

jobs:
  storage-integration:
    name: Storage Integration Tests
    runs-on: ubuntu-latest
    # Run on push to main, or on PRs only when the `run-integration` label is present
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(join(github.event.pull_request.labels.*.name, ','), 'run-integration')) }}
    # Start MinIO in a step below using docker so the workflow is portable and easier to validate

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, sqlite, curl

      - name: Install Composer dependencies
        run: composer install --no-progress --no-suggest --prefer-dist

      - name: Start MinIO container
        run: |
          # Start MinIO and expose API on 9000 and console on 9001. Use explicit console address so startup is deterministic.
          docker run -d --name minio -p 9000:9000 -p 9001:9001 -e MINIO_ROOT_USER=minioadmin -e MINIO_ROOT_PASSWORD=minioadmin minio/minio@sha256:14cea493d9a34af32f524e538b8346cf79f3321eff8e708c1e2960462bd8936e server /data --console-address ":9001"

      - name: Wait for MinIO
        run: |
          # Wait up to 60s for MinIO to be ready. Try health endpoint first, then fallback to root path.
          for i in {1..60}; do
            if curl -sS http://127.0.0.1:9000/minio/health/live >/dev/null 2>&1; then
              echo "MinIO ready (health)" && break
            fi
            if curl -sS http://127.0.0.1:9000/ >/dev/null 2>&1; then
              echo "MinIO responding at root" && break
            fi
            echo "waiting for minio... ($i)"
            sleep 1
          done

      - name: Configure env for MinIO
        run: |
          # Use 127.0.0.1 explicitly so processes in this runner use the loopback address (matches tests)
          echo "AWS_ACCESS_KEY_ID=minioadmin" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=minioadmin" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=us-east-1" >> $GITHUB_ENV
          echo "AWS_BUCKET=test-bucket" >> $GITHUB_ENV
          echo "AWS_ENDPOINT=http://127.0.0.1:9000" >> $GITHUB_ENV
          echo "AWS_USE_PATH_STYLE_ENDPOINT=true" >> $GITHUB_ENV
          # Enable detailed MinIO debug output for this CI run
          echo "CI_DEBUG_MINIO=true" >> $GITHUB_ENV

      - name: Create S3 bucket
        run: |
          # Use mc (MinIO client) to create bucket
          curl -sSfL https://dl.min.io/client/mc/release/linux-amd64/mc -o mc && chmod +x mc
          ./mc alias set local http://localhost:9000 minioadmin minioadmin --api S3v4
          ./mc mb -p local/test-bucket || true

      - name: Wait for S3 API to accept operations (mc)
        run: |
          echo "Waiting for MinIO S3 API to accept operations (mc ls local/test-bucket)"
          for i in {1..60}; do
            ./mc ls local/test-bucket > /dev/null 2>&1 && echo "MinIO S3 API ready" && break
            echo "MinIO not ready yet (attempt: $i), sleeping 1s"
            sleep 1
          done

      - name: Install AWS CLI and create bucket via aws
        run: |
          python -m pip install --user --upgrade pip
          python -m pip install --user awscli
          export PATH="$HOME/.local/bin:$PATH"
          aws --version
          aws --endpoint-url http://localhost:9000 s3api create-bucket --bucket test-bucket || echo "bucket create failed or exists"

      - name: "Optional debug: CI_DEBUG_MINIO detailed diagnostics"
        run: |
          mkdir -p minio-debug
          if [ "${CI_DEBUG_MINIO:-}" = 'true' ]; then
            echo "Writing docker ps to minio-debug/docker-ps.txt"
            docker ps --no-trunc > minio-debug/docker-ps.txt 2>&1 || true

            echo "Writing minio logs to minio-debug/minio-logs.txt"
            docker logs minio --tail 200 > minio-debug/minio-logs.txt 2>&1 || true

            echo "Writing mc ls output to minio-debug/mc-ls.txt"
            curl -sSfL https://dl.min.io/client/mc/release/linux-amd64/mc -o mc && chmod +x mc || true
            ./mc alias set local http://127.0.0.1:9000 minioadmin minioadmin --api S3v4 > minio-debug/mc-alias.txt 2>&1 || true
            ./mc ls local > minio-debug/mc-ls.txt 2>&1 || true

            echo "Writing aws s3 ls to minio-debug/aws-s3-ls.txt"
            aws --endpoint-url http://127.0.0.1:9000 s3 ls > minio-debug/aws-s3-ls.txt 2>&1 || true
          else
            echo "CI_DEBUG_MINIO not set; skipping detailed MinIO debug"
          fi

      - name: "Pre-test lightweight debug dump"
        run: |
          echo "---- docker ps (short) ----"
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' || true
          echo "---- minio health check ----"
          curl -sS -D - http://127.0.0.1:9000/minio/health/live || true
          echo "---- mc ls local/test-bucket ----"
          ./mc alias set local http://127.0.0.1:9000 minioadmin minioadmin --api S3v4 || true
          ./mc ls local/test-bucket || true

      # NOTE: debug artifact upload removed to reduce noise; keep debug files available
      # in the workflow logs or re-enable uploads temporarily when needed.
      - name: Dump S3 env and Laravel S3 config (debug)
        run: |
          echo "--- S3 ENV VARS (CI) ---"
          echo "AWS_BUCKET=$AWS_BUCKET"
          echo "AWS_ENDPOINT=$AWS_ENDPOINT"
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
          echo "AWS_SECRET_ACCESS_KEY=$( [ -n "$AWS_SECRET_ACCESS_KEY" ] && echo '***' || echo '(empty)')"
          echo "FILESYSTEM_DISK=$FILESYSTEM_DISK"
          echo ""
          echo "--- Laravel filesystems.disks.s3 config ---"
          php -r "require 'vendor/autoload.php'; \$app = require 'bootstrap/app.php'; \$kernel = \$app->make(Illuminate\\Contracts\\Console\\Kernel::class); \$kernel->bootstrap(); var_export(config('filesystems.disks.s3'));"

      - name: Run integration tests (capture output + junit)
        run: |
          mkdir -p artifacts/phpunit || true
          # Run phpunit; write console output and JUnit XML for artifact upload
          vendor/bin/phpunit --configuration phpunit.xml --group integration --colors=never --log-junit artifacts/phpunit/phpunit-results.xml 2>&1 | tee artifacts/phpunit/phpunit-console.log

      # PHPUnit artifacts upload removed to avoid storing logs as artifacts on every run.
      # If you need artifacts for debugging, re-enable this step temporarily.
